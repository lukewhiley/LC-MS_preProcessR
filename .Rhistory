)
#remove sltr (only x per plate)
master_list$data$peakArea$wide <- master_list$data$peakArea$wide %>%
filter(sampleType != "sltr")
#export RDA
save(
master_list,
file = paste0(file.path,
Sys.Date(), "_",
master_list$project_details$project_name,
"_SPE_",
master_list$project_details$wash,
"_checkpoint_1_combined.rda"
)
)
master_list
#export RDA
save(
master_list,
file = paste0(file.path,
Sys.Date(), "_",
master_list$project_details$project_name,
"_SPE_",
master_list$project_details$wash,
"_checkpoint_1_combined.rda"
)
)
paste0(file.path,
Sys.Date(), "_",
master_list$project_details$project_name,
"_SPE_",
master_list$project_details$wash,
"_checkpoint_1_combined.rda"
)
file.path
file.path = "C:\\Users\\300828F\\Murdoch University\\Luke Whiley - HDR students - Manthan - Manthan\\data\\"
#export RDA
save(
master_list,
file = paste0(file.path,
Sys.Date(), "_",
master_list$project_details$project_name,
"_SPE_",
master_list$project_details$wash,
"_checkpoint_1_combined.rda"
)
)
master_list$data$peakArea$wide
master_list$data$peakArea$wide %>% .$samplePlate(unique)
master_list$data$peakArea$wide %>% .$samplePlate %>% unique()
silSigal <- tibble(
sampleID = master_list$data$peakArea$wide %>%
.$sampleID,
summedSignal = master_list$data$peakArea$wide %>%
select(!contains("sample")) %>%
select(contains("-sil")) %>%
rowSums(na.rm = TRUE)
)
metaboliteSignal <- tibble(
sampleID = master_list$data$peakArea$wide %>%
.$sampleID,
summedSignal = master_list$data$peakArea$wide %>%
select(!contains("sample")) %>%
select(!contains("-sil")) %>%
rowSums(na.rm = TRUE)
)
flaggedSamples <- unique(
c(
silSigal[["sampleID"]][which(silSigal$summedSignal < (median(silSigal$summedSignal)*0.01))],
metaboliteSignal[["sampleID"]][which(metaboliteSignal$summedSignal < (median(metaboliteSignal$summedSignal)*0.01))]
))
master_list$data$peakArea$wideFiltered <- master_list$data$peakArea$wide %>%
filter(!sampleID %in% flaggedSamples)
flaggedFeature <- NULL
#idx_metabolite <- "8-OH-2-dG"
#idx_metabolite = names(master_list$data$peakArea$wide %>% select(!contains("sample")))[1] #for testign loop
for(idx_metabolite in names(master_list$data$peakArea$wide %>% select(!contains("sample")))){
#calculate for sample
sampleMissing <- which(is.na(master_list$data$peakArea$wideFiltered %>% filter(sampleType == "sample") %>% .[[idx_metabolite]])) %>% length()
samplePercent <- (100/(master_list$data$peakArea$wideFiltered %>% filter(sampleType == "sample") %>% nrow()))*sampleMissing
#calculate for pqc
pqcMissing <- which(is.na(master_list$data$peakArea$wideFiltered %>% filter(sampleType == "pqc") %>% .[[idx_metabolite]])) %>% length()
pqcPercent <- (100/(master_list$data$peakArea$wideFiltered %>% filter(sampleType == "pqc") %>% nrow()))*pqcMissing
#caculcate for ltr
ltrMissing <- which(is.na(master_list$data$peakArea$wideFiltered %>% filter(sampleType == "ltr") %>% .[[idx_metabolite]])) %>% length()
ltrPercent <- (100/(master_list$data$peakArea$wideFiltered %>% filter(sampleType == "ltr") %>% nrow()))*ltrMissing
#if is a non-SIL standard
if(!grepl("SIL", idx_metabolite)){
if(samplePercent > 75.5 | pqcPercent > 25.5){ #} | ltrPercent >20){
flaggedFeature = c(flaggedFeature, idx_metabolite)
}
}
#if it is a SIL standard
if(grepl("SIL", idx_metabolite)){
if(samplePercent > 15.5 | pqcPercent > 15.5){ # | ltrPercent >25){
flaggedFeature = c(flaggedFeature, idx_metabolite)
}
}
}
#create final dataSet
master_list$data$peakArea$wideFiltered <- master_list$data$peakArea$wideFiltered %>%
select(!all_of(flaggedFeature))
#keep a record of the metabolite names before and after clean names
master_list$templates[["metaboliteNames"]] <- tibble(
oldNames = master_list$data$peakArea$wideFiltered %>% names(),
newNames = master_list$data$peakArea$wideFiltered %>% clean_names() %>% names()
) %>%
add_column(
tidyName = gsub("\\..*", "", gsub("-QC", "", gsub("_.*", "", .$oldNames))) %>% toupper(),
experiment = NA,
polarity = NA,
rt = NA,
silUsed = NA#,
#pqcRSD = NA
) %>%
filter(!grepl("sample", oldNames))
#add full name from scout master
idx_name = (master_list$templates[["metaboliteNames"]][["tidyName"]])[1]
for(idx_name in (master_list$templates[["metaboliteNames"]][["tidyName"]])){
oldName = master_list$templates[["metaboliteNames"]]$oldNames[which(master_list$templates[["metaboliteNames"]]$tidyName == idx_name)]
#add experiment type
experiment = master_list$templates$msMethod$experiment[which(toupper(master_list$templates$msMethod$metabolite) == toupper(oldName))] %>% toupper() %>% unique()
#add to meta table
if(length(experiment)==1){
master_list$templates[["metaboliteNames"]]$experiment[which(master_list$templates[["metaboliteNames"]]$oldNames == oldName)] <-
experiment
}
#find polarity
polarity = master_list$templates$msMethod$polarity[which(toupper(master_list$templates$msMethod$metabolite) == toupper(oldName))] %>% tolower() %>% unique()
#add polarity to meta table
if(length(polarity)==1){
master_list$templates[["metaboliteNames"]]$polarity[which(master_list$templates[["metaboliteNames"]]$oldNames == oldName)] <-
polarity
}
#find rt
rt = mean(na.rm=TRUE,
c(
master_list$data$peakRegionFinal[[oldName]] %>% .$peakStartRT %>% as.numeric(),
master_list$data$peakRegionFinal[[oldName]] %>% .$peakEndRT %>% as.numeric())
) %>% round(3)
#add RT to meta table
master_list$templates[["metaboliteNames"]]$rt[which(master_list$templates[["metaboliteNames"]]$oldNames == oldName)] <- rt
}#close idx_name loop
#split into sub-plates
master_list$data$peakArea[["sorted"]] <- list()
for(idx_plate in unique(master_list$data$peakArea$wideFiltered$samplePlate)){
master_list$data$peakArea$sorted[[idx_plate]] <- master_list$data$peakArea$wideFiltered %>% filter(samplePlate == idx_plate) %>% clean_names()
}
#impute function
#add LGW impute function
lgw_impute <- function(x){
map(.x = x, .f = ~ (min(.x[.x > 0], na.rm = TRUE))/2) %>%
#use replace_na to replace NAs with min/2 value
replace_na(
data = x %>% mutate_all(~ replace(., . == 0, NA)), #note - replace zeros with NA to make compatible with replace_na()
replace = .) #note - replace with list of min/2 values generated from map function in pipe (.)
}
#set data list
master_list$data$peakArea$imputed <- list()
#run loop in all plates
for(idx_plate in names(master_list$data$peakArea$sorted)){
#set all 0, NaN, is.infinate to a NA value for consistency
#create matrix
master_list$data$peakArea$imputed[[idx_plate]]  <- master_list$data$peakArea$sorted[[idx_plate]] %>%
column_to_rownames("sample_id") %>%
select(-contains("sample")) %>%
as.matrix()
#replace 0, NaN and Inf with NA for imputation (min/2)
master_list$data$peakArea$imputed[[idx_plate]][master_list$data$peakArea$imputed[[idx_plate]] ==0] <- NA
master_list$data$peakArea$imputed[[idx_plate]][is.infinite(master_list$data$peakArea$imputed[[idx_plate]])] <- NA
master_list$data$peakArea$imputed[[idx_plate]][is.nan(master_list$data$peakArea$imputed[[idx_plate]])] <- NA
#run lgw_impute function
master_list$data$peakArea$imputed[[idx_plate]] <- master_list$data$peakArea$imputed[[idx_plate]] %>%
as.data.frame() %>%
lgw_impute() %>%
rownames_to_column("sample_id") %>%
as_tibble() %>%
#samples that are 100% missing (zero/na) have imputation error as min/2(x) is inf. So this step replaces inf with zeros (will be flagged for filter later anyway).
mutate_all(function(x) ifelse(is.infinite(x), 1, x)) %>%
left_join(
master_list$data$peakArea$sorted[[idx_plate]] %>%
select(contains("sample")),
.,
by = "sample_id"
) %>%
add_column(
sampleDataSource = ".peakArea"
) %>% clean_names()
}
master_list$data$peakArea$combat <- list()
# for SIL
dataImputed <- master_list$data$peakArea$imputed %>%
bind_rows() %>%
select(
contains("sample"),
contains("_sil", ignore.case = TRUE)
)
dataPreCombat <- dataImputed %>%
select(sample_id, !contains("sample")) %>%
#offset by constant factor of 1 for lof step later
mutate(
across(where(is.numeric), ~ .x+1)
) %>%
column_to_rownames("sample_id") %>%
t() %>%
log10()
#extract batch
batch = dataImputed %>%
.$sample_plate
#perform batch correction
dataPostCombat <- sva::ComBat(
dat = as.matrix(dataPreCombat),
batch = batch,
mod = NULL,           # or NULL
par.prior = TRUE,
prior.plots = FALSE,
mean.only = FALSE          # set TRUE if you only want mean-shift correction
#ref.batch = 1
)
# sometimes combat gives neg values, offset factor constant to remove this option
for(idx_metaboliteRow in 1:nrow(dataPostCombat)){
minRow = min(dataPostCombat[idx_metaboliteRow,], na.rm = TRUE)
if(minRow < 0){
dataPostCombat[idx_metaboliteRow, ] <- dataPostCombat[idx_metaboliteRow, ] + abs(minRow*2)
}
}
# unlog data
dataPostCombat2 <- left_join(
by = "sample_id",
dataImputed %>% select(contains("sample")),
((10^dataPostCombat) - 1) %>% # per-feature log nd offset removal
round(3) %>%
t(.) %>%
as.data.frame() %>%
lgw_impute() %>%
rownames_to_column("sample_id") %>%
as_tibble()
)
# repeat for non Sil data
# for SIL
dataImputed <- master_list$data$peakArea$imputed %>%
bind_rows() %>%
select(
contains("sample"),
!contains("_sil", ignore.case = TRUE)
)
dataPreCombat <- dataImputed %>%
select(sample_id, !contains("sample")) %>%
#offset by constant factor of 1 for lof step later
mutate(
across(where(is.numeric), ~ .x+1)
) %>%
column_to_rownames("sample_id") %>%
t() %>%
log10()
#extract batch
batch = dataImputed %>%
.$sample_plate
#perform batch correction
dataPostCombat <- sva::ComBat(
dat = as.matrix(dataPreCombat),
batch = batch,
mod = NULL,           # or NULL
par.prior = TRUE,
prior.plots = FALSE,
mean.only = FALSE          # set TRUE if you only want mean-shift correction
#ref.batch = 1
)
# sometimes combat gives neg values, offset factor constant to remove this option
for(idx_metaboliteRow in 1:nrow(dataPostCombat)){
minRow = min(dataPostCombat[idx_metaboliteRow,], na.rm = TRUE)
if(minRow < 0){
dataPostCombat[idx_metaboliteRow, ] <- dataPostCombat[idx_metaboliteRow, ] + abs(minRow*2)
}
}
# unlog data
dataPostCombat2 <- dataPostCombat2 %>%
left_join(
by = "sample_id",
.,
((10^dataPostCombat) - 1) %>% # per-feature log nd offset removal
round(3) %>%
t(.) %>%
as.data.frame() %>%
lgw_impute() %>%
rownames_to_column("sample_id") %>%
as_tibble()
) %>%
select(
master_list$data$peakArea$imputed %>%
bind_rows() %>%
names()
)
for(idx_plate in master_list$data$peakArea$impute %>% names()){
master_list$data$peakArea$combat[[idx_plate]] <- dataPostCombat2 %>%
filter(sample_plate == idx_plate)
}
skylineR_directory <- paste0(master_list$project_details$project_dir, "\\", master_list$project_details$wash)
if(!dir.exists(paste0(skylineR_directory, "\\statTarget"))){
dir.create(paste0(skylineR_directory, "\\statTarget"))
}
master_list$project_details$project_dir = "C:\\Users\\300828F\\Murdoch University\\Luke Whiley - HDR students - Manthan - Manthan\\testing"
skylineR_directory <- paste0(master_list$project_details$project_dir, "\\", master_list$project_details$wash)
if(!dir.exists(paste0(skylineR_directory, "\\statTarget"))){
dir.create(paste0(skylineR_directory, "\\statTarget"))
}
skylineR_directory <- paste0(master_list$project_details$project_dir)
if(!dir.exists(paste0(skylineR_directory, "\\statTarget"))){
dir.create(paste0(skylineR_directory, "\\statTarget"))
}
#set qc-type
#set dummy value for while loop
master_list$project_details$statTarget_qc_type <- "hold"
#run while loop
while(master_list$project_details$statTarget_qc_type != "LTR" & master_list$project_details$statTarget_qc_type != "VLTR" & master_list$project_details$statTarget_qc_type != "PQC"){
master_list$project_details$statTarget_qc_type <- dlgInput("which qc type will be used for statTarget", "VLTR/LTR/PQC - default is PQC")$res
}
#create data list
FUNC_list <- list()
FUNC_list$project_dir <- paste0(skylineR_directory,
"\\statTarget")
#set up project folders for batch correct
#create directories
if(!dir.exists(paste0(FUNC_list$project_dir,"/", Sys.Date(), "_sigCorResults"))){
dir.create(paste0(FUNC_list$project_dir,"/", Sys.Date(), "_sigCorResults"))
}
setwd(paste0(FUNC_list$project_dir,"/", Sys.Date(), "_sigCorResults"))
#apply on peakArea data (post-impute)
#set master data for function
FUNC_list$master_data <- bind_rows(master_list$data$peakArea$imputed)
#set_qc type used for signal drift correction
FUNC_list$master_data[["sample_type"]] <- "sample"
FUNC_list$master_data[["sample_type"]][which(tolower(FUNC_list$master_data[["sample_type_factor"]]) == tolower(master_list$project_details$statTarget_qc_type))] <- "qc"
#flag QCs that have failed because of mis-injection (very low signal (<10 % of median))
temp.rowSums <- FUNC_list$master_data %>%
filter(sample_type_factor == master_list$project_details$statTarget_qc_type) %>%
select(!contains("sample")) %>%
rowSums()
#find file names
temp.qcFail <- (FUNC_list$master_data  %>%
filter(sample_type_factor == master_list$project_details$statTarget_qc_type) %>%
.$sample_name)[which(temp.rowSums < median(temp.rowSums*0.1))]
#reset failed QC injections to "sample" so is not included in statTarget algorithm
FUNC_list$master_data[["sample_type"]][which(FUNC_list$master_data[["sample_name"]] %in% temp.qcFail)] <- "sample"
#flag low number of QCs using ratio of QC to total samples
for(idxPlate in names(master_list$data$peakArea$imputed)){
plateData <- FUNC_list$master_data %>% filter(sample_plate == idxPlate)
totalSamples <- length(plateData %>% .$sample_type_factor)
requiredQCs <- (6/96) # Minimum of 6 QC for 96 samples
qcCount <- length(which(tolower(plateData$sample_type) == "qc"))
qcCountRatio <- (qcCount/totalSamples)
dlg_message(paste0(idxPlate, " has ", qcCount, " ", master_list$project_details$statTarget_qc_type, "s for use by statTarget"), "ok")
if(qcCountRatio < requiredQCs || qcCount < 2){
dlg_message(paste0("You do not have enough QCs for statTarget on plate ",idxPlate,". Stopping qcCheckeR. Please remove plate ",idxPlate," and re-run chunk."), type = 'ok')
FUNC_list$corrected_data$data <- NULL
}
}
#exclude failed qcs (see chunk above to id failed QCs)
FUNC_list$master_data[["sample_type"]]
#set metabolite list
FUNC_list$metabolite_list <- master_list$data$peakArea$imputed %>%
bind_rows() %>%
select(-contains("sample")) %>%
names()
#### 1.5.a. create the required metadata file (PhenoFile) for statTarget::shiftCor---------------------------------------------------------------
FUNC_list$PhenoFile <- list()
# build PhenoFile file template
FUNC_list$PhenoFile$template <- FUNC_list$master_data %>%
select(all_of("sample_name")) %>%
dplyr::rename(sample = all_of("sample_name")) %>%
add_column(FUNC_list$master_data %>%
select(all_of("sample_name"))) %>%
add_column(FUNC_list$master_data %>%
select(all_of("sample_plate"))) %>%
add_column(FUNC_list$master_data %>%
select(all_of("sample_type"))) %>%
dplyr::rename(class = all_of("sample_type")) %>%
add_column(FUNC_list$master_data %>%
select(all_of("sample_type"))) %>%
add_column(FUNC_list$master_data %>%
select(all_of("sample_run_index")))
#### arrange by run order
FUNC_list$PhenoFile$template <- FUNC_list$PhenoFile$template %>%
arrange_at("sample_run_index")
FUNC_list$PhenoFile$template_qc_order <- NULL
qc_idx <- NULL
for(idx_batch in FUNC_list$PhenoFile$template %>%
select(all_of("sample_plate")) %>%
unique() %>%
as.matrix() %>%
c()
){
#create a temp tibble batch specific
loop_temp_data <- FUNC_list$PhenoFile$template %>%
filter(!!as.symbol("sample_plate") == idx_batch)
#ensure a sample_type "qc" is "first" and "last" in the worklist order. Required for statTarget::shiftCor
loop_qc_idx <- which(loop_temp_data %>%
select(all_of("sample_type"))
== "qc")
# browser()
#if qc is not run before the samples - artificially move first qc to run order position 1. This is required for statTarget
if(loop_qc_idx[1] > 1){
loop_temp_data <- loop_temp_data %>%
slice(loop_qc_idx[1],1:nrow(loop_temp_data)) %>%
slice(-(loop_qc_idx[1]+1))
}
#create last qc
if(loop_qc_idx[length(loop_qc_idx)] < nrow(loop_temp_data)){
loop_temp_data <- loop_temp_data %>%
slice(1:nrow(loop_temp_data), loop_qc_idx[length(loop_qc_idx)]) %>%
slice(-loop_qc_idx[length(loop_qc_idx)])
}
#create total qc_idx for use later
qc_idx <- c(qc_idx,
loop_qc_idx)
FUNC_list$PhenoFile$template_qc_order <- bind_rows(FUNC_list$PhenoFile$template_qc_order,
loop_temp_data)
}
#set sample column for statTarget requires "QC" in QC rows, and sample name in sample rows
FUNC_list$PhenoFile$template_qc_order$sample[which(FUNC_list$PhenoFile$template_qc_order %>%
select(all_of("sample_type")) == "qc")] <- paste0("QC", rep(1:length(qc_idx)))
FUNC_list$PhenoFile$template_qc_order$sample[which(FUNC_list$PhenoFile$template_qc_order %>%
select(all_of("sample_type")) == "sample")] <- paste0("sample",
rep(1:(nrow(FUNC_list$PhenoFile$template_qc_order)-length(qc_idx))))
#set NA for class column in rows that are NA
FUNC_list$PhenoFile$template_qc_order$class[which(FUNC_list$PhenoFile$template_qc_order %>%
select(all_of("sample_type")) == "qc")] <- NA
#rename column header for statTarget template
FUNC_list$PhenoFile$template_sample_id <- FUNC_list$PhenoFile$template_qc_order %>%
dplyr::rename(sample_id = all_of("sample_name"),
batch = all_of("sample_plate"),
order = all_of("sample_run_index")) %>%
select(sample, batch, class, order, sample_id)
#confirm order columnn is continuous
FUNC_list$PhenoFile$template_sample_id$order <- c(1:nrow(FUNC_list$PhenoFile$template_sample_id))
#set batch/plate - numeric value starting at 1 - max number of plates/batch
temp_batch <- 1
for(idx_batch_set in unique(FUNC_list$PhenoFile$template_sample_id$batch)){
FUNC_list$PhenoFile$template_sample_id$batch[which(FUNC_list$PhenoFile$template_sample_id$batch == idx_batch_set)] <- temp_batch
temp_batch <- temp_batch + 1
}
FUNC_list$PhenoFile$template_sample_id$batch <- FUNC_list$PhenoFile$template_sample_id$batch %>%
as.numeric()
#final Phenofile
FUNC_list$PhenoFile$PhenoFileOut <- FUNC_list$PhenoFile$template_sample_id %>%
select(-sample_id)
# write out as csv (requirement for statTarget::shiftCor)
write_csv(x = FUNC_list$PhenoFile$PhenoFileOut,
file = paste(getwd(), "/PhenoFile.csv", sep="")
)
#### 1.5.b. create data for statTarget::shiftCor  -----------------------------------
FUNC_list$ProfileFile <- list()
#must have samples in columns and metabolites in rows
FUNC_list$ProfileFile$template  <- FUNC_list$master_data %>%
select(all_of("sample_name"),
all_of(FUNC_list$metabolite_list)) %>%
dplyr::rename(sample_id = !!"sample_name")
#match run order to PhenoFile
FUNC_list$ProfileFile$template_qc_order <- FUNC_list$PhenoFile$template_sample_id %>%
select(sample, sample_id) %>%
left_join(FUNC_list$ProfileFile$template, by = "sample_id") %>%
select(-sample_id)
#transpose tibble for statTarget
FUNC_list$ProfileFile$ProfileFile <- as_tibble(
cbind(nms = names(FUNC_list$ProfileFile$template_qc_order),
t(FUNC_list$ProfileFile$template_qc_order))
) %>%
setNames(.[1,]) %>%
dplyr::rename(name = sample) %>%
filter(name != "sample") %>%
mutate(across(!contains("name", ignore.case = FALSE), as.numeric))
#create a metabolite list and create metabolite code
FUNC_list$ProfileFile$metabolite_list <- FUNC_list$ProfileFile$ProfileFile %>%
select(name) %>%
add_column(metabolite_code = paste0("M", rep(1:nrow(FUNC_list$ProfileFile$ProfileFile))))
#add metabolite code to data
FUNC_list$ProfileFile$ProfileFile <- left_join(
FUNC_list$ProfileFile$metabolite_list,
FUNC_list$ProfileFile$ProfileFile,
by = "name") %>%
select(-name) %>%
dplyr::rename(name = metabolite_code)
# write out as csv (requirement for statTarget::shiftCor)
write_csv(x = FUNC_list$ProfileFile$ProfileFile,
file = paste0(getwd(), "/ProfileFile.csv")
)
#script files
samPeno <- paste(getwd(), "\\PhenoFile.csv", sep="")
samFile <- paste(getwd(),  "\\ProfileFile.csv", sep="")
#create_directories
if(!dir.exists(paste(getwd(), "shiftCor", sep = "\\"))){
dir.create(paste(getwd(), "shiftCor", sep = "\\"))
}
#and subDir
if(!dir.exists(paste(getwd(), "shiftCor", "Before_shiftCor", sep = "\\"))){
dir.create(paste(getwd(), "shiftCor", "Before_shiftCor", sep = "\\"))
}
#check nchar
if(nchar(paste(getwd(), "shiftCor", "Before_shiftCor", sep = "\\")) >= 225){
svDialogs::dlg_message(paste0("WARNING: your path length is ", nchar(paste(getwd(), "shiftCor", "Before_shiftCor", sep = "\\")), " characters. Beware - windows path limit is 260, you may experience a path error. If chunk errors, relocate project to a shorter path (e.g. desktop) for processing"))
}
#run statTarget
statTarget::shiftCor(samPeno = samPeno,
samFile =  samFile,
Frule = 0,
ntree = 500,
MLmethod = 'QCRFSC',
imputeM = "minHalf",
plot = FALSE,
coCV = 10000
)
flaggedFeature
