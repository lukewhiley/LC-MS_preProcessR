}
#identify Q ion channel
Q_ion <- q_tibble$ms_channel[which.max(q_tibble$mean_int)]
master_list$data$peakRegion[[idx_metabolite]]$Q_q <- "q"
master_list$data$peakRegion[[idx_metabolite]]$Q_q[which(master_list$data$peakRegion[[idx_metabolite]]$ms_channel == Q_ion)] <- "Q"
#finalise peak bounday of Q ion
idx_plate = unique(master_list$data$peakRegion[[idx_metabolite]]$samplePlate)[1] #for testing loop
#for(idx_plate in unique(master_list$data$peakRegion[[idx_metabolite]]$samplePlate)[1]){ #for testing loop
for(idx_plate in unique(master_list$data$peakRegion[[idx_metabolite]]$samplePlate)){
print(idx_plate)
plate_data <- master_list$data$peakRegion[[idx_metabolite]] %>%
filter(samplePlate==idx_plate) %>%
filter(Q_q == "Q")
master_list$data$peakRegionFinal[[idx_metabolite]] <- bind_rows(
master_list$data$peakRegionFinal[[idx_metabolite]],
tibble(
sample_plate = idx_plate,
ms_function = plate_data$ms_function %>% unique(),
ms_channel_Q = plate_data$ms_channel %>% unique(),
ms_header_id = plate_data$ms_header_id %>% unique(),
metabolite = idx_metabolite,
precursor_mz = plate_data$precursor_mz %>% unique() %>% round(2),
product_mz = plate_data$product_mz %>% unique() %>% round(2),
mrm = paste0(plate_data$precursor_mz %>% unique() %>% round(2), " > " , plate_data$product_mz %>% unique() %>% round(2)),
peakStartRT = (((plate_data$peakStartRT %>% min(na.rm = TRUE)) *100) %>% floor()) /100,
peakEndRT =  (((plate_data$peakEndRT %>% min(na.rm = TRUE)) *100) %>% ceiling()) /100,
peakApexRT = plate_data$peakApexRT %>% mean(na.rm = TRUE) %>% round(2),
peakStartIndex = plate_data$peakStartIndex %>% min(na.rm = TRUE) %>% round(2),
peakEndIndex = plate_data$peakEndIndex %>% max(na.rm = TRUE) %>% round(2)
)
)
}#idx_plate
}#idx_metabolite
master_list$data$peakRegionSIL <- list()
#set object to temp store checkMzMLs
checkMzml <- list()
idx_plate = master_list$project_details$plateList[1] #for testing
#for(idx_plate in master_list$project_details$plateList){
for(idx_plate in master_list$project_details$plateList){
#find index of check solution within idx_plate mzml directory
checkIndex <- master_list$data$mzR[[idx_plate]][grep("vLTR", master_list$data$mzR[[idx_plate]], ignore.case = TRUE)]
idx_mzML = checkIndex[1] #for testing loop
for(idx_mzML in checkIndex){
#read in mzML
if(!gsub("(?i).mzml", "", idx_mzML) %in% names(checkMzml)){
#create mzR object
checkMzml[[gsub("(?i).mzml", "", idx_mzML)]]$mzR_object <- mzR::openMSfile(
filename = paste0(master_list$project_details$plateDirList[grepl(idx_plate, master_list$project_details$plateDirList)], "/", idx_mzML)
)
#create mzR header
checkMzml[[gsub("(?i).mzml", "", idx_mzML)]]$mzR_header <- mzR::chromatogramHeader(
checkMzml[[gsub("(?i).mzml", "", idx_mzML)]]$mzR_object) %>%
as_tibble() %>%
#mutate to avoid low value decimal making error in the output
mutate(precursorIsolationWindowTargetMZ = round(precursorIsolationWindowTargetMZ, 4),
productIsolationWindowTargetMZ = round(productIsolationWindowTargetMZ, 4))
#create mzR chromatogram
checkMzml[[gsub("(?i).mzml", "", idx_mzML)]]$mzR_chromatogram <- mzR::chromatograms(
checkMzml[[gsub("(?i).mzml", "", idx_mzML)]]$mzR_object)
}
#cycle through each function to extract the chrom data
#for testing
idx_function = "FUNCTION_15"
for(idx_function in unique(master_list$templates$msMethodLong %>% filter(grepl("SIL", metabolite)) %>% .$mrmFunction)){
#get metabolite string
mrm_metabolite = master_list$templates$msMethodLong %>%
filter(mrmFunction == idx_function) %>%
.$metabolite %>%
unique()
#get chromatogram header data
mzmlFuncHeader <- checkMzml[[gsub("(?i).mzml", "", idx_mzML)]]$mzR_header %>%
filter(grepl(paste0(gsub("_","=", casefold(idx_function)), " "), chromatogramId))
#do a check in case the functions have been updated in the project and change between files
if(FALSE %in% (c(
mzmlFuncHeader$precursorIsolationWindowTargetMZ %in% (master_list$templates$msMethodLong %>% filter(mrmFunction == idx_function) %>% .$q1 %>% unique()),
mzmlFuncHeader$productIsolationWindowTargetMZ %in% (master_list$templates$msMethodLong %>% filter(mrmFunction == idx_function) %>% .$q3 %>% unique())
))){
#update idx_function
idx_function = checkMzml[[gsub("(?i).mzml", "", idx_mzML)]]$mzR_header %>%
filter(precursorIsolationWindowTargetMZ %in% (master_list$templates$msMethodLong %>% filter(mrmFunction == idx_function) %>% .$q1 %>% unique())) %>%
filter(productIsolationWindowTargetMZ %in% (master_list$templates$msMethodLong %>% filter(mrmFunction == idx_function) %>% .$q3 %>% unique())) %>%
.$chromatogramId %>%
gsub(".*function=", "function=", . ) %>%
gsub(" .*", "", .) %>%
gsub("=", "_", .) %>%
toupper() %>%
unique()
#update header
mzmlFuncHeader <- checkMzml[[gsub("(?i).mzml", "", idx_mzML)]]$mzR_header %>%
filter(grepl(paste0(gsub("_","=", casefold(idx_function)), " "), chromatogramId))
}
#set channel index (within msFunction) for storing later
channel_index = 1
idx_mrm = mzmlFuncHeader$chromatogramIndex[1]#for testing
for(idx_mrm in mzmlFuncHeader$chromatogramIndex){
#get metabolite metadata
row_index = which(mzmlFuncHeader$chromatogramIndex==idx_mrm)
#store mrm details
precursor_mz = mzmlFuncHeader$precursorIsolationWindowTargetMZ[row_index]
product_mz = mzmlFuncHeader$productIsolationWindowTargetMZ[row_index]
#set empty object for storing peak boundaries
if(!mrm_metabolite %in% names(master_list$data$peakRegionSIL)){
master_list$data$peakRegionSIL[[mrm_metabolite]] <- list()
}
#set modifiable loop chromatogram
loopChromatogram <- checkMzml[[gsub("(?i).mzml", "", idx_mzML)]]$mzR_chromatogram[[idx_mrm]] %>%
as_tibble() %>%
add_column(.before = 1,
scanIndex = 1:nrow(.)
) %>%
setNames(c("scanIndex", "time", "intensity"))
#create peak table
peakTable = tibble()
#fl.count = 9
smoothData <- loopChromatogram %>%
select(scanIndex, time) %>%
add_column(
intensity = loopChromatogram$intensity %>%
pracma::savgol(fl = 7, forder = 0, dorder = 0) %>%
pracma::savgol(fl = 5, forder = 0, dorder = 0) %>%
pracma::savgol(fl = 3, forder = 0, dorder = 0)
)
smoothData <- smoothData %>%
as.matrix() %>%
smoothr::smooth_chaikin(., wrap = FALSE) %>%
as_tibble() %>%
setNames(c("scanIndex", "time", "intensity"))
#reset baseline to help findPeaks
smoothData$intensity[which(smoothData$intensity <
(sd(smoothData$intensity)*0.1))] <- min(smoothData$intensity)
#create peak table
peakTable <- smoothData[["intensity"]] %>%
pracma::findpeaks(x=., nups = 5, ndowns = 5,  minpeakdistance = 20, sortstr = TRUE, minpeakheight = sd(.)) %>%
as_tibble() %>% setNames(c("intensity", "peakApexIndex", "peakStartIndex", "peakEndIndex"))
if(nrow(peakTable) == 0){
peakTable <- tibble(
intensity = max(smoothData$intensity),
peakApexIndex = which.max(smoothData$intensity),
peakStartIndex = which(smoothData$intensity > min(smoothData$intensity))[1],
peakEndIndex = rev(which(smoothData$intensity > min(smoothData$intensity)))[1]
)
}
#set index of which peak to use from peakDetect table
peakTableRow = 1
#store peak details
peakApexInt <- peakTable[["intensity"]][peakTableRow]
peakApexIndex <- peakTable[["peakApexIndex"]][peakTableRow]; peakApexRT <- smoothData[["time"]][peakApexIndex]
peakStartIndex <- peakTable[["peakStartIndex"]][peakTableRow]; peakStartRT <- smoothData[["time"]][peakStartIndex]
peakEndIndex <- peakTable[["peakEndIndex"]][peakTableRow]; peakEndRT <- smoothData[["time"]][peakEndIndex]
peakWidth <- peakEndIndex-peakStartIndex
#creat a tibble to define peak
master_list$data$peakRegionSIL[[mrm_metabolite]] <- bind_rows(
master_list$data$peakRegionSIL[[mrm_metabolite]],
tibble(
ms_function = idx_function,
ms_channel = channel_index,
ms_header_id = idx_mrm,
sampleMetabolite = mrm_metabolite,
mrm = paste0(round(precursor_mz,2), " > ", round(product_mz,2)),
precursor_mz = precursor_mz,
product_mz = product_mz,
samplePlate = idx_plate,
sampleName = idx_mzML,
peakApexInt = peakApexInt,
peakStartRT = peakStartRT,
peakApexRT = peakApexRT,
peakEndRT = peakEndRT,
peakStartIndex =peakStartIndex,
peakApexIndex = peakApexIndex,
peakEndIndex =peakEndIndex,
peakWidth = peakWidth,
#flCount = fl.count
)
)
channel_index <- channel_index+1
} #idx_mrm
} #idx_function
} #idx_mzML
} #idx_plate
## finalise peak boundaries
#identify Q and q ions and finalise boundaries per plate
master_list$data$peakRegionSILFinal <- list()
#idx_metabolite = names(master_list$data$peakRegionSIL)[13]#for testing loop
#idx_metabolite = "LTE4"
for(idx_metabolite in names(master_list$data$peakRegionSIL)){
master_list$data$peakRegionSILFinal[[idx_metabolite]] <- list()
#first ID Q ion across plate
q_tibble <- list()
idx_channel = unique(master_list$data$peakRegionSIL[[idx_metabolite]]$ms_channel)[1]
for(idx_channel in unique(master_list$data$peakRegionSIL[[idx_metabolite]]$ms_channel)){
mean_intensity = master_list$data$peakRegionSIL[[idx_metabolite]] %>%
filter(ms_channel == idx_channel) %>%
.$peakApexInt %>%
median(na.rm = TRUE)
q_tibble <- bind_rows(
q_tibble,
tibble(
ms_channel = idx_channel,
mean_int = mean_intensity)
)
}
#identify Q ion channel
Q_ion <- q_tibble$ms_channel[which.max(q_tibble$mean_int)]
master_list$data$peakRegionSIL[[idx_metabolite]]$Q_q <- "q"
master_list$data$peakRegionSIL[[idx_metabolite]]$Q_q[which(master_list$data$peakRegionSIL[[idx_metabolite]]$ms_channel == Q_ion)] <- "Q"
#finalise peak bounday of Q ion
idx_plate = unique(master_list$data$peakRegionSIL[[idx_metabolite]]$samplePlate)[1] #for testing loop
#for(idx_plate in unique(master_list$data$peakRegionSIL[[idx_metabolite]]$samplePlate)[1]){ #for testing loop
for(idx_plate in unique(master_list$data$peakRegionSIL[[idx_metabolite]]$samplePlate)){
plate_data <- master_list$data$peakRegionSIL[[idx_metabolite]] %>%
filter(samplePlate==idx_plate) %>%
filter(Q_q == "Q")
master_list$data$peakRegionSILFinal[[idx_metabolite]] <- bind_rows(
master_list$data$peakRegionSILFinal[[idx_metabolite]],
tibble(
sample_plate = idx_plate,
ms_function = plate_data$ms_function %>% unique(),
ms_channel_Q = plate_data$ms_channel %>% unique(),
ms_header_id = plate_data$ms_header_id %>% unique(),
metabolite = idx_metabolite,
precursor_mz = plate_data$precursor_mz %>% unique() %>% round(2),
product_mz = plate_data$product_mz %>% unique() %>% round(2),
mrm = paste0(plate_data$precursor_mz %>% unique() %>% round(2), " > " , plate_data$product_mz %>% unique() %>% round(2)),
peakStartRT = (((plate_data$peakStartRT %>% min(na.rm = TRUE)) *100) %>% floor()) /100,
peakEndRT =  (((plate_data$peakEndRT %>% min(na.rm = TRUE)) *100) %>% ceiling()) /100,
peakApexRT = plate_data$peakApexRT %>% mean(na.rm = TRUE) %>% round(2),
peakStartIndex = plate_data$peakStartIndex %>% min(na.rm = TRUE) %>% round(2),
peakEndIndex = plate_data$peakEndIndex %>% max(na.rm = TRUE) %>% round(2)
)
)
}#idx_plate
}#idx_metabolite
#merge lists together and sort
master_list$data$peakRegionFinal <- master_list$data$peakRegionFinal %>%
append(
master_list$data$peakRegionSILFinal
)
master_list$data$peakRegionFinal <- master_list$data$peakRegionFinal[order(names(master_list$data$peakRegionFinal))]
#1 export plots of check and LTR and PQC
#create review folders
#create dir.
if(!dir.exists(paste0(master_list$project_details$project_dir, "/", master_list$project_details$wash, "/plots"))){
dir.create(paste0(master_list$project_details$project_dir, "/", master_list$project_details$wash, "/plots"))
}
if(!dir.exists(paste0(master_list$project_details$project_dir, "/", master_list$project_details$wash, "/plots/peakReview"))){
dir.create(paste0(master_list$project_details$project_dir, "/", master_list$project_details$wash, "/plots/peakReview"))
}
#set plot colors
plotColors = c(
check = "#E41A1C" ,
ltr = "#4DAF4A",
pqc = "#FF7F00"
)
#open pdf device
pdf(
onefile = TRUE, width = 11.7, height = 4,
file = #gsub("", "-",
paste0(
master_list$project_details$project_dir, "/", master_list$project_details$wash, "/plots/peakReview/", Sys.Date(), "_", master_list$project_details$project_name,
"_all_metabolites_peakReview.pdf"
)
#)
)
#start at metabolite level
#cycle through each mrm and produce a peak review plot
#idx_mrm = "TOL"
i = 1
totalMRM = length(master_list$data$peakRegionFinal %>% bind_rows() %>% arrange(metabolite) %>% .$metabolite %>% unique())
#for(idx_mrm in c("GCA", "GCA-SIL_d4")){ # for testing
for(idx_mrm in (master_list$data$peakRegionFinal %>% bind_rows() %>% arrange(metabolite) %>% .$metabolite %>% unique() ) ){
message(paste0("printing ", i, " of ", totalMRM, " metabolites: ", idx_mrm))
print(ggplot() +
annotate("text", x = 4, y = 25, size=8, label = idx_mrm) +
theme_void())
#get plate information
peakReview <- list()
reviewPlotDataAll <- list()
for(idx_plate in master_list$project_details$plateList){
print(idx_plate)
#get precursor and product info from peakRegion table
precursor_mz = master_list$data$peakRegionFinal[[idx_mrm]] %>%
filter(sample_plate == idx_plate) %>%
.$precursor_mz %>%
unique()
product_mz = master_list$data$peakRegionFinal[[idx_mrm]] %>%
filter(sample_plate == idx_plate) %>%
.$product_mz %>%
unique()
#find mrm function in the mzML file
mzml_mrm <- master_list$data$peakRegionFinal[[idx_mrm]] %>%
filter(sample_plate == idx_plate) %>%
.$ms_header_id
#print plate function
print(paste0("plate MS function = ", mzml_mrm))
#peakStart in check
peakStartRT = master_list$data$peakRegionFinal[[idx_mrm]] %>%
filter(sample_plate == idx_plate) %>%
.$peakStartRT %>% round(digits = 3) %>%
unique()
#peakEnd in check
peakEndRT = master_list$data$peakRegionFinal[[idx_mrm]] %>%
filter(sample_plate == idx_plate) %>%
.$peakEndRT %>% round(digits = 3) %>%
unique()
#peakApex in check
peakApexRT = master_list$data$peakRegionFinal[[idx_mrm]] %>%
filter(sample_plate == idx_plate) %>%
.$peakApexRT %>% round(digits = 3) %>%
unique()
peakReview[[idx_plate]] <- list(
`mzML.list` = c(
master_list$data$mzR[[idx_plate]][grepl("(?i)check", master_list$data$mzR[[idx_plate]])],
master_list$data$mzR[[idx_plate]][grepl("(?i)_ltr", master_list$data$mzR[[idx_plate]])],
master_list$data$mzR[[idx_plate]][grepl("(?i)_pqc", master_list$data$mzR[[idx_plate]])]
)
)
#create empty list
peakReview[[idx_plate]][["chromatograms"]] <- list()
#now cycle through each mzML
idx_mzML = peakReview[[idx_plate]]$mzML.list[1]
for(idx_mzML in peakReview[[idx_plate]]$mzML.list){
#read in chromatogram
#temp mzml object
tempMzml <- list(
mzR_object =  mzR::openMSfile(
filename = paste0(master_list$project_details$project_dir, "/", master_list$project_details$wash, "/data/mzml/",idx_plate, "/", idx_mzML)
)
)
#create mzR header
tempMzml$mzR_header <- mzR::chromatogramHeader(tempMzml$mzR_object)
#work around fix to fix issue where some projects have a method mismatch that mis-aligns the chromatogramIndex
if(length(mzml_mrm) > 1){
mzml_mrm = tempMzml$mzR_header %>%
as_tibble() %>%
filter(chromatogramIndex %in% mzml_mrm) %>%
filter(floor(precursorIsolationWindowTargetMZ) == floor(precursor_mz)) %>%
filter(floor(productIsolationWindowTargetMZ) == floor(product_mz)) %>%
.$chromatogramIndex
}
#create mzR chromatogram
tempMzml$mzR_chromatogram <- mzR::chromatograms(tempMzml$mzR_object)
peakReview[[idx_plate]]$chromatograms[[idx_mzML]] <- tempMzml
} #end idx mzML
#now extract chromatogram and plot for each mzml across each plate
#create empty data
reviewPlotData <- list()
for(idx_mzML in names(peakReview[[idx_plate]]$chromatograms)){
tempMzml <- list()
tempMzml[["smooth"]] = tibble(
time = peakReview[[idx_plate]]$chromatograms[[idx_mzML]]$mzR_chromatogram[[mzml_mrm]][["rtime"]],
intensity = peakReview[[idx_plate]]$chromatograms[[idx_mzML]]$mzR_chromatogram[[mzml_mrm]][,2] %>%
pracma::savgol(fl = 7, forder = 0, dorder = 0) %>%
pracma::savgol(fl = 5, forder = 0, dorder = 0) %>%
pracma::savgol(fl = 3, forder = 0, dorder = 0)
) %>% setNames(c("time", "intensity")) %>%
add_column(.before=1,
sampleName = idx_mzML,
samplePlate = idx_plate,
sampleMetabolite = idx_mrm,
precursor_mz = precursor_mz,
product_mz = product_mz) %>%
add_column(.after = "sampleName",
sampleFacet = sub("(?i)_fepp_", ".", paste0(gsub("_.*", "", .$sampleName), "_", gsub(".*@", "", .$sampleName)))
)
reviewPlotData <- bind_rows(
reviewPlotData,
tempMzml$smooth
)
} #idx_mzML
#add a sample_type column
reviewPlotData <- reviewPlotData %>%
add_column(sample_type = "check")
reviewPlotData$sample_type[grepl("(?i)ltr", reviewPlotData$sampleFacet)] <- "ltr"
reviewPlotData$sample_type[grepl("(?i)pqc", reviewPlotData$sampleFacet)] <- "pqc"
#print plot
print(
ggplot(
data = reviewPlotData, aes(x = time, y = intensity, color = sample_type)
) +
geom_line(alpha = 0.5, linetype = "solid") +
#facet_wrap(facets = "sampleFacet", scales = "free_y", ncol  = 2) +
facet_wrap(facets = c("samplePlate", "sample_type"), scales = "free_y", ncol = 3) +
scale_color_manual(values = plotColors) +
geom_vline(xintercept = peakEndRT) +
geom_vline(xintercept = peakStartRT) +
theme_bw() +
ggtitle(paste0(idx_mrm, "; ", idx_plate, "; integration start = ", peakStartRT, "; integration end = ", peakEndRT)) +
scale_x_continuous(breaks = round(seq(min(reviewPlotData$time), max(reviewPlotData$time), by = 0.1), 1)) +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
)
} #idx_plate
i = i+1
} #idx_mrm
dev.off()
message(paste0("printing ", i, " of ", totalMRM, " metabolites: ", idx_mrm))
peakReview <- list()
reviewPlotDataAll <- list()
for(idx_plate in master_list$project_details$plateList){
print(idx_plate)
#get precursor and product info from peakRegion table
precursor_mz = master_list$data$peakRegionFinal[[idx_mrm]] %>%
filter(sample_plate == idx_plate) %>%
.$precursor_mz %>%
unique()
product_mz = master_list$data$peakRegionFinal[[idx_mrm]] %>%
filter(sample_plate == idx_plate) %>%
.$product_mz %>%
unique()
#find mrm function in the mzML file
mzml_mrm <- master_list$data$peakRegionFinal[[idx_mrm]] %>%
filter(sample_plate == idx_plate) %>%
.$ms_header_id
#print plate function
print(paste0("plate MS function = ", mzml_mrm))
#peakStart in check
peakStartRT = master_list$data$peakRegionFinal[[idx_mrm]] %>%
filter(sample_plate == idx_plate) %>%
.$peakStartRT %>% round(digits = 3) %>%
unique()
#peakEnd in check
peakEndRT = master_list$data$peakRegionFinal[[idx_mrm]] %>%
filter(sample_plate == idx_plate) %>%
.$peakEndRT %>% round(digits = 3) %>%
unique()
#peakApex in check
peakApexRT = master_list$data$peakRegionFinal[[idx_mrm]] %>%
filter(sample_plate == idx_plate) %>%
.$peakApexRT %>% round(digits = 3) %>%
unique()
peakReview[[idx_plate]] <- list(
`mzML.list` = c(
master_list$data$mzR[[idx_plate]][grepl("(?i)check", master_list$data$mzR[[idx_plate]])],
master_list$data$mzR[[idx_plate]][grepl("(?i)_ltr", master_list$data$mzR[[idx_plate]])],
master_list$data$mzR[[idx_plate]][grepl("(?i)_pqc", master_list$data$mzR[[idx_plate]])]
)
)
#create empty list
peakReview[[idx_plate]][["chromatograms"]] <- list()
#now cycle through each mzML
idx_mzML = peakReview[[idx_plate]]$mzML.list[1]
for(idx_mzML in peakReview[[idx_plate]]$mzML.list){
#read in chromatogram
#temp mzml object
tempMzml <- list(
mzR_object =  mzR::openMSfile(
filename = paste0(master_list$project_details$project_dir, "/", master_list$project_details$wash, "/data/mzml/",idx_plate, "/", idx_mzML)
)
)
#create mzR header
tempMzml$mzR_header <- mzR::chromatogramHeader(tempMzml$mzR_object)
#work around fix to fix issue where some projects have a method mismatch that mis-aligns the chromatogramIndex
if(length(mzml_mrm) > 1){
mzml_mrm = tempMzml$mzR_header %>%
as_tibble() %>%
filter(chromatogramIndex %in% mzml_mrm) %>%
filter(floor(precursorIsolationWindowTargetMZ) == floor(precursor_mz)) %>%
filter(floor(productIsolationWindowTargetMZ) == floor(product_mz)) %>%
.$chromatogramIndex
}
#create mzR chromatogram
tempMzml$mzR_chromatogram <- mzR::chromatograms(tempMzml$mzR_object)
peakReview[[idx_plate]]$chromatograms[[idx_mzML]] <- tempMzml
} #end idx mzML
#now extract chromatogram and plot for each mzml across each plate
#create empty data
reviewPlotData <- list()
for(idx_mzML in names(peakReview[[idx_plate]]$chromatograms)){
tempMzml <- list()
tempMzml[["smooth"]] = tibble(
time = peakReview[[idx_plate]]$chromatograms[[idx_mzML]]$mzR_chromatogram[[mzml_mrm]][["rtime"]],
intensity = peakReview[[idx_plate]]$chromatograms[[idx_mzML]]$mzR_chromatogram[[mzml_mrm]][,2] %>%
pracma::savgol(fl = 7, forder = 0, dorder = 0) %>%
pracma::savgol(fl = 5, forder = 0, dorder = 0) %>%
pracma::savgol(fl = 3, forder = 0, dorder = 0)
) %>% setNames(c("time", "intensity")) %>%
add_column(.before=1,
sampleName = idx_mzML,
samplePlate = idx_plate,
sampleMetabolite = idx_mrm,
precursor_mz = precursor_mz,
product_mz = product_mz) %>%
add_column(.after = "sampleName",
sampleFacet = sub("(?i)_fepp_", ".", paste0(gsub("_.*", "", .$sampleName), "_", gsub(".*@", "", .$sampleName)))
)
reviewPlotData <- bind_rows(
reviewPlotData,
tempMzml$smooth
)
} #idx_mzML
#add a sample_type column
reviewPlotData <- reviewPlotData %>%
add_column(sample_type = "check")
reviewPlotData$sample_type[grepl("(?i)ltr", reviewPlotData$sampleFacet)] <- "ltr"
reviewPlotData$sample_type[grepl("(?i)pqc", reviewPlotData$sampleFacet)] <- "pqc"
#print plot
print(
ggplot(
data = reviewPlotData, aes(x = time, y = intensity, color = sample_type)
) +
geom_line(alpha = 0.5, linetype = "solid") +
#facet_wrap(facets = "sampleFacet", scales = "free_y", ncol  = 2) +
facet_wrap(facets = c("samplePlate", "sample_type"), scales = "free_y", ncol = 3) +
scale_color_manual(values = plotColors) +
geom_vline(xintercept = peakEndRT) +
geom_vline(xintercept = peakStartRT) +
theme_bw() +
ggtitle(paste0(idx_mrm, "; ", idx_plate, "; integration start = ", peakStartRT, "; integration end = ", peakEndRT)) +
scale_x_continuous(breaks = round(seq(min(reviewPlotData$time), max(reviewPlotData$time), by = 0.1), 1)) +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
)
} #idx_plate
idx_plate
