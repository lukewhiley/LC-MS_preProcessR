## 1.5. statTarget signalDrift | batch correction ----------------------------

#create batch correction directory

skylineR_directory <- paste0(master_list$project_details$project_dir, "\\", master_list$project_details$wash)

#data

if(!dir.exists(paste0(skylineR_directory, "\\statTarget"))){
  dir.create(paste0(skylineR_directory, "\\statTarget"))
}

#set qc-type
master_list$project_details$statTarget_qc_type <- dlgInput("which qc type will be used for statTarget", "VLTR/LTR/PQC - default is PQC")$res


#create data list 
FUNC_list <- list()
FUNC_list$project_dir <- paste0(skylineR_directory,
                                "\\statTarget")

#set up project folders for batch correct
#create directories 
if(!dir.exists(paste0(FUNC_list$project_dir,"/", Sys.Date(), "_sigCorResults"))){
  dir.create(paste0(FUNC_list$project_dir,"/", Sys.Date(), "_sigCorResults"))
}

setwd(paste0(FUNC_list$project_dir,"/", Sys.Date(), "_sigCorResults")) 

#apply on peakArea data (post-impute)
#set master data for function
FUNC_list$master_data <- bind_rows(master_list$data$peakArea$imputed)
#set_qc type used for signal drift correction
FUNC_list$master_data[["sample_type"]] <- "sample"
FUNC_list$master_data[["sample_type"]][which(tolower(FUNC_list$master_data[["sample_type_factor"]]) == tolower(master_list$project_details$statTarget_qc_type))] <- "qc"

#flag QCs that have failed because of mis-injection (very low signal (<10 % of median))
temp.rowSums <- FUNC_list$master_data %>%
  filter(sample_type_factor == master_list$project_details$statTarget_qc_type) %>%
  select(!contains("sample")) %>%
  rowSums()
#find file names
temp.qcFail <- (FUNC_list$master_data  %>%
                  filter(sample_type_factor == master_list$project_details$statTarget_qc_type) %>%
                  .$sample_name)[which(temp.rowSums < median(temp.rowSums*0.1))]

#reset failed QC injections to "sample" so is not included in statTarget algorithm
FUNC_list$master_data[["sample_type"]][which(FUNC_list$master_data[["sample_name"]] %in% temp.qcFail)] <- "sample"


#flag low number of QCs using ratio of QC to total samples
for(idxPlate in names(master_list$data$peakArea$imputed)){
  
  plateData <- FUNC_list$master_data %>% filter(sample_plate == idxPlate)
  totalSamples <- length(plateData %>% .$sample_type_factor)
  requiredQCs <- (6/96) # Minimum of 6 QC for 96 samples
  qcCount <- length(which(tolower(plateData$sample_type) == "qc"))
  qcCountRatio <- (qcCount/totalSamples)
  dlg_message(paste0(idxPlate, " has ", qcCount, " ", master_list$project_details$statTarget_qc_type, "s for use by statTarget"), "ok")
  
  if(qcCountRatio < requiredQCs || qcCount < 2){
    dlg_message(paste0("You do not have enough QCs for statTarget on plate ",idxPlate,". Stopping qcCheckeR. Please remove plate ",idxPlate," and re-run chunk."), type = 'ok')
    FUNC_list$corrected_data$data <- NULL
  }
}


#exclude failed qcs (see chunk above to id failed QCs)
FUNC_list$master_data[["sample_type"]]

#set metabolite list
FUNC_list$metabolite_list <- master_list$data$peakArea$imputed %>%
  bind_rows() %>%
  select(-contains("sample")) %>%
  names()

#### 1.5.a. create the required metadata file (PhenoFile) for statTarget::shiftCor---------------------------------------------------------------
FUNC_list$PhenoFile <- list()
# build PhenoFile file template
FUNC_list$PhenoFile$template <- FUNC_list$master_data %>% 
  select(all_of("sample_name")) %>%
  dplyr::rename(sample = all_of("sample_name")) %>%
  add_column(FUNC_list$master_data %>% 
               select(all_of("sample_name"))) %>%
  add_column(FUNC_list$master_data %>%
               select(all_of("sample_plate"))) %>%
  add_column(FUNC_list$master_data %>%
               select(all_of("sample_type"))) %>%
  dplyr::rename(class = all_of("sample_type")) %>% 
  add_column(FUNC_list$master_data %>%
               select(all_of("sample_type"))) %>%
  add_column(FUNC_list$master_data %>%
               select(all_of("sample_run_index")))

#### arrange by run order
FUNC_list$PhenoFile$template <- FUNC_list$PhenoFile$template %>%
  arrange_at("sample_run_index")

#### QC placement
#stat target needs a qc at postion 1 and last position in the run. Default run order takes this into account, but some datasets this is not the case
#in this instance this section of code artificially moves the first and last qc into position. It is completed for each batch.

FUNC_list$PhenoFile$template_qc_order <- NULL
qc_idx <- NULL
for(idx_batch in FUNC_list$PhenoFile$template %>% 
    select(all_of("sample_plate")) %>%
    unique() %>%
    as.matrix() %>%
    c()
){
  
  #create a temp tibble batch specific
  loop_temp_data <- FUNC_list$PhenoFile$template %>%
    filter(!!as.symbol("sample_plate") == idx_batch)
  
  #ensure a sample_type "qc" is "first" and "last" in the worklist order. Required for statTarget::shiftCor
  loop_qc_idx <- which(loop_temp_data %>% 
                         select(all_of("sample_type")) 
                       == "qc")
  # browser()
  #if qc is not run before the samples - artificially move first qc to run order position 1. This is required for statTarget
  if(loop_qc_idx[1] > 1){
    loop_temp_data <- loop_temp_data %>%
      slice(loop_qc_idx[1],1:nrow(loop_temp_data)) %>%
      slice(-(loop_qc_idx[1]+1))
  }
  
  #create last qc
  if(loop_qc_idx[length(loop_qc_idx)] < nrow(loop_temp_data)){
    loop_temp_data <- loop_temp_data %>%
      slice(1:nrow(loop_temp_data), loop_qc_idx[length(loop_qc_idx)]) %>%
      slice(-loop_qc_idx[length(loop_qc_idx)])
  }
  
  #create total qc_idx for use later
  qc_idx <- c(qc_idx,
              loop_qc_idx)
  
  FUNC_list$PhenoFile$template_qc_order <- bind_rows(FUNC_list$PhenoFile$template_qc_order,
                                                     loop_temp_data)
  
}

#set sample column for statTarget requires "QC" in QC rows, and sample name in sample rows
FUNC_list$PhenoFile$template_qc_order$sample[which(FUNC_list$PhenoFile$template_qc_order %>% 
                                                     select(all_of("sample_type")) == "qc")] <- paste0("QC", rep(1:length(qc_idx)))
FUNC_list$PhenoFile$template_qc_order$sample[which(FUNC_list$PhenoFile$template_qc_order %>% 
                                                     select(all_of("sample_type")) == "sample")] <- paste0("sample", 
                                                                                                           rep(1:(nrow(FUNC_list$PhenoFile$template_qc_order)-length(qc_idx))))
#set NA for class column in rows that are NA
FUNC_list$PhenoFile$template_qc_order$class[which(FUNC_list$PhenoFile$template_qc_order %>% 
                                                    select(all_of("sample_type")) == "qc")] <- NA

#rename column header for statTarget template
FUNC_list$PhenoFile$template_sample_id <- FUNC_list$PhenoFile$template_qc_order %>% 
  dplyr::rename(sample_id = all_of("sample_name"),
                batch = all_of("sample_plate"),
                order = all_of("sample_run_index")) %>%
  select(sample, batch, class, order, sample_id)

#confirm order columnn is continuous
FUNC_list$PhenoFile$template_sample_id$order <- c(1:nrow(FUNC_list$PhenoFile$template_sample_id))

#set batch/plate - numeric value starting at 1 - max number of plates/batch
temp_batch <- 1
for(idx_batch_set in unique(FUNC_list$PhenoFile$template_sample_id$batch)){
  FUNC_list$PhenoFile$template_sample_id$batch[which(FUNC_list$PhenoFile$template_sample_id$batch == idx_batch_set)] <- temp_batch
  temp_batch <- temp_batch + 1
}

FUNC_list$PhenoFile$template_sample_id$batch <- FUNC_list$PhenoFile$template_sample_id$batch %>%
  as.numeric()

#final Phenofile
FUNC_list$PhenoFile$PhenoFileOut <- FUNC_list$PhenoFile$template_sample_id %>%
  select(-sample_id)

# write out as csv (requirement for statTarget::shiftCor)
write_csv(x = FUNC_list$PhenoFile$PhenoFileOut,
          file = paste(getwd(), "/PhenoFile.csv", sep="")
)

#### 1.5.b. create data for statTarget::shiftCor  -----------------------------------
FUNC_list$ProfileFile <- list()

#must have samples in columns and metabolites in rows
FUNC_list$ProfileFile$template  <- FUNC_list$master_data %>%
  select(all_of("sample_name"),
         all_of(FUNC_list$metabolite_list)) %>%
  dplyr::rename(sample_id = !!"sample_name")

#match run order to PhenoFile
FUNC_list$ProfileFile$template_qc_order <- FUNC_list$PhenoFile$template_sample_id %>%
  select(sample, sample_id) %>%
  left_join(FUNC_list$ProfileFile$template, by = "sample_id") %>%
  select(-sample_id)

#transpose tibble for statTarget
FUNC_list$ProfileFile$ProfileFile <- as_tibble(
  cbind(nms = names(FUNC_list$ProfileFile$template_qc_order), 
        t(FUNC_list$ProfileFile$template_qc_order))
) %>%
  setNames(.[1,]) %>%
  dplyr::rename(name = sample) %>%
  filter(name != "sample") %>%
  mutate(across(!contains("name", ignore.case = FALSE), as.numeric))

#create a metabolite list and create metabolite code
FUNC_list$ProfileFile$metabolite_list <- FUNC_list$ProfileFile$ProfileFile %>%
  select(name) %>%
  add_column(metabolite_code = paste0("M", rep(1:nrow(FUNC_list$ProfileFile$ProfileFile))))

#add metabolite code to data
FUNC_list$ProfileFile$ProfileFile <- left_join(
  FUNC_list$ProfileFile$metabolite_list,
  FUNC_list$ProfileFile$ProfileFile,
  by = "name") %>%
  select(-name) %>%
  dplyr::rename(name = metabolite_code)

# write out as csv (requirement for statTarget::shiftCor)
write_csv(x = FUNC_list$ProfileFile$ProfileFile, 
          file = paste0(getwd(), "/ProfileFile.csv")
)

#script files
samPeno <- paste(getwd(), "\\PhenoFile.csv", sep="")
samFile <- paste(getwd(),  "\\ProfileFile.csv", sep="")

#create_directories
if(!dir.exists(paste(getwd(), "shiftCor", sep = "\\"))){
  dir.create(paste(getwd(), "shiftCor", sep = "\\"))
}

#and subDir
if(!dir.exists(paste(getwd(), "shiftCor", "Before_shiftCor", sep = "\\"))){
  dir.create(paste(getwd(), "shiftCor", "Before_shiftCor", sep = "\\"))
}


#check nchar
if(nchar(paste(getwd(), "shiftCor", "Before_shiftCor", sep = "\\")) >= 225){
  svDialogs::dlg_message(paste0("WARNING: your path length is ", nchar(paste(getwd(), "shiftCor", "Before_shiftCor", sep = "\\")), " characters. Beware - windows path limit is 260, you may experience a path error. If chunk errors, relocate project to a shorter path (e.g. desktop) for processing"))
}

                 
#run statTarget
statTarget::shiftCor(samPeno = samPeno,
                     samFile =  samFile,
                     Frule = 0,
                     ntree = 500,
                     MLmethod = 'QCRFSC',
                     imputeM = "minHalf",
                     plot = FALSE,
                     coCV = 10000
)

#read back in csv

FUNC_list$corrected_data$data <- read_csv(
  paste0(getwd(), "/statTarget/shiftCor/After_shiftCor/shift_all_cor.csv"),
  show_col_types = FALSE)

#different versions of r/statTarget appear to produce shift_all_cor in different orientations. Some have metabolites in columns some in rows. Unsure as to why, I did not find out which package inside statTarget was producing this outcome.
#the next phase fixes this by performing a check as to the orientation of the csv

#older packages (metab lites in rows)
if("sample1" %in% colnames(FUNC_list$corrected_data$data)){
  FUNC_list$corrected_data$data  <- FUNC_list$corrected_data$data  %>%
    filter(sample != "class") %>%
    dplyr::rename(name = sample) %>%
    mutate(across(!contains("name", ignore.case = FALSE), as.numeric))
}

#updated packages (metabolites in columns)
if("M1" %in% colnames(FUNC_list$corrected_data$data)){
  FUNC_list$corrected_data$data  <- FUNC_list$corrected_data$data  %>%
    t() %>% data.frame() %>%
    rownames_to_column() %>% 
    as_tibble() %>%
    setNames(.[1,]) %>%
    filter(sample != "class" & sample != "sample" ) %>%
    dplyr::rename(name = sample) %>%
    mutate(across(!contains("name", ignore.case = FALSE), as.numeric))
}

#recombine with sample filenames and lipid names
FUNC_list$corrected_data$data_transposed <- right_join(
  FUNC_list$ProfileFile$metabolite_list %>% dplyr::rename(lipid = metabolite_code),
  FUNC_list$corrected_data$data %>% dplyr::rename(lipid = name),
  by = "lipid"
) %>%
  select(-lipid) %>%
  as.matrix() %>%
  t() %>% data.frame() %>%
  rownames_to_column() %>% 
  as_tibble() %>%
  setNames(.[1,]) %>%
  filter(name!="name") %>%
  mutate(across(!contains("name", ignore.case = FALSE), as.numeric)) %>%
  dplyr::rename(sample = name) %>%
  left_join(x = FUNC_list$PhenoFile$template_sample_id,
            y = .,
            by = "sample") %>%
  dplyr::rename(!!"sample_name" := sample_id) %>%
  left_join(
    x = FUNC_list$master_data %>%
      select(contains("sample")),
    y = .,
    by = "sample_name"
  ) %>%
  select(-all_of(c("sample", "batch", "class", "order")))

#### 1.5.c. post-statTarget peak area mean adjustment ------------------------------------
#because the statTarget correction changes the output signal area of the lipids, this next section re-scales the values based on the change (ratio) between pre and post corrected signal mean in the QCs
#step one - get mean value for each metabolite in the QC samples - pre-single drift corrected data 
FUNC_list$corrected_data$qc_means <- FUNC_list$master_data %>%
  filter(!!as.symbol("sample_type") == "qc") %>%
  select(-contains("sample")) %>%
  colMeans() %>%
  as_tibble() %>%
  dplyr::rename(original_mean = value) %>%
  add_column(metabolite = FUNC_list$master_data %>%
               select(-contains("sample")) %>%
               names(), 
             .before = "original_mean") %>%
  #step two - get mean value for each metabolite in the QC samples - post-single drift corrected data 
  left_join(.,
            FUNC_list$corrected_data$data_transposed %>%
              filter(!!as.symbol("sample_type") == "qc") %>%
              select(-contains("sample")) %>%
              colMeans() %>%
              data.frame %>%
              rownames_to_column() %>%
              as_tibble() %>%
              setNames(c("metabolite", "corrected_mean")),
            by = "metabolite") %>%
  #step three - create ratio factor for concentration adjustment
  add_column(correction_ratio = .$corrected_mean/.$original_mean)

#step 4 - adjust data concentrations
FUNC_list$corrected_data$data_qc_mean_adjusted <- FUNC_list$corrected_data$data_transposed
#run loop
for(idx_metabolite in FUNC_list$corrected_data$qc_means$metabolite){
  FUNC_list$corrected_data$data_qc_mean_adjusted[[idx_metabolite]] <- FUNC_list$corrected_data$data_qc_mean_adjusted[[idx_metabolite]]/
    FUNC_list$corrected_data$qc_means[["correction_ratio"]][which(FUNC_list$corrected_data$qc_means[["metabolite"]]==idx_metabolite)]
}

#return QC type to ltr data
FUNC_DATA_qc_type <- unique(bind_rows(master_list$data$peakArea$sorted)$sample_type_factor[which(bind_rows(master_list$data$peakArea$sorted)$sample_type =="qc")]) %>% as.character()
FUNC_list$corrected_data$data_qc_mean_adjusted$sample_type <- FUNC_list$corrected_data$data_qc_mean_adjusted$sample_type_factor
#FUNC_list$corrected_data$data_qc_mean_adjusted$sample_type[which(FUNC_list$corrected_data$data_qc_mean_adjusted$sample_type_factor == FUNC_DATA_qc_type)] <- "qc"

FUNC_list

#list for storing signal drift corrected data (per project)
master_list$data$peakArea$statTarget <- list()
#loop to back into plate elements of list
for(idx_batch in unique(FUNC_list$corrected_data$data_qc_mean_adjusted$sample_plate)){
  master_list$data$peakArea$statTarget[[idx_batch]] <- FUNC_list$corrected_data$data_qc_mean_adjusted %>%
    filter(sample_plate == idx_batch) %>%
    mutate(across(where(is.numeric), round, 0))
  #set dataSource
  master_list$data$peakArea$statTarget[[idx_batch]]$sample_data_source <- "peakArea.statTarget"
}

#reset wd to project dir
setwd(master_list$project_details$project_dir)

#remove extra files
rm(list = c(ls()[which(ls() != "master_list")]))
